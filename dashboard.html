<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circled Fight</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <style>
        .header { position: relative; }
        .hamburger-menu { position: absolute; top: 8px; right: 12px; background: transparent; border: 0; color: var(--codm-yellow); font-size: 1.6rem; padding: 6px; border-radius:6px; z-index:1200; cursor:pointer; }
        .hamburger-menu:focus { outline: 2px solid rgba(255,193,7,0.25); }
        .mobile-hub { position: absolute; right: 12px; top: 44px; width: 86vw; max-width:320px; background:#1b1b1b; border:1px solid #333; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,.6); transform-origin:top right; transform:scale(.95); opacity:0; visibility:hidden; transition:opacity 180ms ease, transform 180ms ease, visibility 180ms; z-index:1199; }
        .mobile-hub.open { transform:scale(1); opacity:1; visibility:visible; }
        .mobile-hub ul { list-style:none; margin:0; padding:8px 0; }
        .mobile-hub li { padding:8px 14px; }
        .mobile-hub a { color:var(--text-main); text-decoration:none; display:block; font-weight:600; }
        .mobile-hub a:hover { color:var(--codm-yellow); }
        .mobile-hub-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.25); opacity:0; visibility:hidden; transition:opacity 180ms ease, visibility 180ms; z-index:1150; }
        .mobile-hub-backdrop.visible { opacity:1; visibility:visible; }
        @media (min-width:900px){ .mobile-hub{ top:54px; width:260px; } }
        /* Sidebar header: place subtitle/meta under the title on a single line */
        .sidebar-header { display: block; padding: 12px 15px; }
        .sidebar-header h3 { margin: 0 0 6px 0; }
        .sidebar-header .meta-line { display: flex; gap: 10px; align-items: center; }

    </style>
</head>
<body>
    
    <div class="header">
        <div>
            <h1>Circled fight <span style="font-size:0.5em; color:white; vertical-align:middle; border:1px solid white; padding:2px 5px; border-radius:3px;">Cf</span></h1>
            <span style="color: var(--text-muted);">Suivi des performances hebdomadaires</span>
            <div style="color: var(--text-muted); font-size:0.8em; margin-top:4px;">Site crÃ©Ã© par CfÂ°3L_Angelos</div>
        </div>

        <div class="export-container">
            <button class="export-btn" onclick="exportChart()">ðŸ“¸ Export Graph</button>
            <div class="mvp-badge" id="mvpBadge">
                <span>MVP SEMAINE ACTUELLE</span>
                <strong id="mvpName">--</strong>
            </div>
        </div>

        <!-- Hamburger button top-right -->
        <button id="hamburgerMenu" class="hamburger-menu" aria-controls="dashboardMobileHub" aria-expanded="false" aria-label="Ouvrir le menu">â˜°</button>
        <nav id="dashboardMobileHub" class="mobile-hub" aria-hidden="true">
            <ul>
                <li><a href="index.html">Accueil</a></li>
                <li><a href="members.html">Membres du Clan</a></li>
                <li><a href="dashboard.html">Scores MJ</a></li>
                <li><a href="br_dashboard.html">Scores BR</a></li>
                <li><a href="paris.html">Espace Paris</a></li>
                <li><a href="tournament.html">Tournoi du Week-end</a></li>
                <li><a href="1v1.html">1v1</a></li>                
                <li><a href="join.html">Nous Rejoindre</a></li>
            </ul>
        </nav>
        <div id="dashboardMobileHubBackdrop" class="mobile-hub-backdrop" tabindex="-1" aria-hidden="true"></div>
    </div>

    <script>
        // Small hamburger toggle (non-intrusive)
        (function(){
            const btn = document.getElementById('hamburgerMenu');
            const hub = document.getElementById('dashboardMobileHub');
            const backdrop = document.getElementById('dashboardMobileHubBackdrop');
            if(!btn || !hub || !backdrop) return;
            function openHub(){ hub.classList.add('open'); backdrop.classList.add('visible'); btn.setAttribute('aria-expanded','true'); hub.setAttribute('aria-hidden','false'); const first = hub.querySelector('a'); if(first) first.focus(); }
            function closeHub(){ hub.classList.remove('open'); backdrop.classList.remove('visible'); btn.setAttribute('aria-expanded','false'); hub.setAttribute('aria-hidden','true'); btn.focus(); }
            btn.addEventListener('click', ()=>{ const opened = btn.getAttribute('aria-expanded')==='true'; if(opened) closeHub(); else openHub(); });
            backdrop.addEventListener('click', closeHub);
            document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeHub(); });
            hub.addEventListener('click', (e)=>{ if(e.target.tagName==='A') closeHub(); });
        })();
    </script>

    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>CLASSEMENT MJ     </h3>
                <small style="color:#777;">Par Moyenne</small>
                <div class="meta-line">
                    <small>Cliquer sur nom pour (dÃ©)masquer sur le graphique</small>
                    
                </div>
            </div>
            <ul class="rank-list" id="playerList">
                </ul>
            <div class="controls">
                <button class="btn" onclick="toggleAll(true)">Tout Voir</button>
                <button class="btn" onclick="toggleAll(false)">Masquer</button>
            </div>
        </div>

        <div class="main-content">
            <div class="chart-wrapper">
                <canvas id="clanChart"></canvas>
            </div>
            
            <div class="versus-panel" id="versusPanel">
                <div class="vs-player" id="p1-container">
                    <div class="vs-name" id="p1-name" style="color:cyan">Player 1</div>
                    <div class="vs-score" id="p1-avg">85.5</div>
                    <div class="vs-stat">Moyenne</div>
                </div>
                <div class="vs-icon">VS</div>
                <div class="vs-player" id="p2-container">
                    <div class="vs-name" id="p2-name" style="color:orange">Player 2</div>
                    <div class="vs-score" id="p2-avg">82.0</div>
                    <div class="vs-stat">Moyenne</div>
                </div>
            </div>
        </div>
    </div>

    <div class="legend-panel">
        <h4>LÃ‰GENDE DES BADGES</h4>
        <div class="badges-list">
            <span>ðŸ”¥N : SÃ©rie de victoires (N semaines de participation consÃ©cutive sans absence).</span>
            <span>ðŸš€ Progression : 3 semaines consÃ©cutives de hausse de score.</span>
            <span>ðŸ’¤ AFK : Aucune participation enregistrÃ©e sur les 2 derniÃ¨res semaines.</span>
        </div>
    </div>

    <script type="module">
    import { weeks, rawData } from "./js/data.js";
    import { detailedData } from "./js/data2.js";

        // Fonction pour calculer l'Ã©cart-type
        function calculateStdDev(scores) {
            const validScores = scores.filter(s => s !== null && s !== undefined);
            if (validScores.length < 2) return Infinity; 
            const mean = validScores.reduce((a, b) => a + b, 0) / validScores.length;
            const variance = validScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validScores.length;
            return Math.sqrt(variance);
        }

        // --- 1. CALCULS, TRENDS & AWARDS (sur toutes les semaines disponibles) ---
        rawData.forEach(player => {
            const validScores = (player.scores || []).filter(s => s !== null && s !== undefined);
            const sum = validScores.reduce((a, b) => a + b, 0);
            player.avg = validScores.length ? (sum / validScores.length).toFixed(1) : 0;

            // lastScore: last non-null within full scores (or 0)
            let lastScore = null;
            for (let i = (player.scores || []).length - 1; i >= 0; i--) {
                if (player.scores[i] !== null && player.scores[i] !== undefined) { lastScore = player.scores[i]; break; }
            }
            player.lastScore = lastScore !== null ? lastScore : 0;

            // ðŸ… BADGES (stdDev calculated on full scores)
            player.stdDev = calculateStdDev(player.scores || []);

            // ðŸ’¤ AFK Check based on the last two full scores
            const lastDataIndex = (player.scores || []).length - 1;
            player.isAFK = (lastDataIndex >= 1) ? (player.scores[lastDataIndex] === null && player.scores[lastDataIndex - 1] === null) : false;

            // ðŸš€ Progression Check (3 hausses consÃ©cutives) within full scores
            let consecutiveIncreases = 0;
            player.isProgression = false;
            for (let i = (player.scores || []).length - 1; i >= 1; i--) {
                const current = player.scores[i];
                const previous = player.scores[i - 1];
                if (current !== null && previous !== null) {
                    if (current > previous) {
                        consecutiveIncreases++;
                        if (consecutiveIncreases >= 3) { player.isProgression = true; break; }
                    } else if (current < previous) { consecutiveIncreases = 0; }
                }
            }

            // ðŸ”¥N STREAK (Participation consÃ©cutive) - check within full scores
            player.streak = 0;
            for (let i = (player.scores || []).length - 1; i >= 0; i--) {
                if (player.scores[i] !== null && player.scores[i] !== undefined) { player.streak++; }
                else break;
            }

            // ðŸ“ˆ TRENDS (last vs previous) within full scores
            let lastRecordedScore = null;
            let prevRecordedScore = null;
            for (let i = (player.scores || []).length - 1; i >= 0; i--) {
                if (player.scores[i] !== null) {
                    if (lastRecordedScore === null) lastRecordedScore = player.scores[i];
                    else if (prevRecordedScore === null) { prevRecordedScore = player.scores[i]; break; }
                }
            }
            player.trend = (lastRecordedScore !== null && prevRecordedScore !== null) ? lastRecordedScore - prevRecordedScore : 0;
        });




        // Trier du meilleur au pire (Moyenne)
        rawData.sort((a, b) => b.avg - a.avg);

        // --- 2. MOYENNE DU CLAN (Ligne FantÃ´me) ---
        const clanAverageScores = weeks.map((_, weekIndex) => {
            let weekTotal = 0;
            let weekCount = 0;
            rawData.forEach(player => {
                const score = player.scores[weekIndex];
                if (score !== null && score !== undefined) {
                    weekTotal += score;
                    weekCount++;
                }
            });
            return weekCount > 0 ? (weekTotal / weekCount) : null;
        });

        function getNeonColor(index) {
            const hues = [180, 300, 60, 120, 20, 250, 0, 330]; 
            const hue = hues[index % hues.length]; 
            const finalHue = hue + (Math.floor(index/hues.length) * 20);
            return `hsl(${finalHue}, 100%, 60%)`;
        }

        // CrÃ©er les datasets des joueurs
        const playerDatasets = rawData.map((player, index) => ({
            label: player.name,
            data: player.scores,
            borderColor: getNeonColor(index),
            backgroundColor: getNeonColor(index),
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4,
            pointBackgroundColor: '#121212', 
            pointBorderWidth: 2,
            spanGaps: true,
            hidden: index > 4 
        }));

        // Dataset de la moyenne du clan (TOUJOURS en premier)
        const clanAvgDataset = {
            label: "Moyenne du Clan",
            data: clanAverageScores,
            borderColor: 'rgba(255, 255, 255, 0.5)', 
            backgroundColor: 'rgba(255, 255, 255, 0.5)',
            borderWidth: 2,
            borderDash: [5, 5], 
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 0,
            fill: false,
            hidden: false 
        };

        const datasets = [clanAvgDataset, ...playerDatasets]; 

        // --- 3. CONFIG DU GRAPH (Plugin Background) ---
        const rankZonesPlugin = {
            id: 'rankZones',
            beforeDraw: (chart) => {
                const { ctx, chartArea: { top, bottom, left, right, width, height }, scales: { y } } = chart;
                
                const drawZone = (yMin, yMax, color) => {
                    const yTop = y.getPixelForValue(yMax);
                    const yBottom = y.getPixelForValue(yMin);
                    ctx.fillStyle = color;
                    ctx.fillRect(left, yTop, width, yBottom - yTop);
                };

                // Dessiner les zones (Backgrounds)
                drawZone(80, 120, 'rgba(0, 230, 118, 0.05)'); // Vert/LÃ©gendaire
                drawZone(40, 80, 'rgba(255, 193, 7, 0.05)');  // Jaune/Pro
                drawZone(0, 40, 'rgba(255, 23, 68, 0.05)');   // Rouge/Rookie
            }
        };

        // --- 4. INITIALISATION CHART ---
        const ctx = document.getElementById('clanChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: { labels: weeks, datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // --- NOUVEAU CODE ---
                interaction: {
                    mode: 'nearest', // Cherche le point le plus proche
                    intersect: false, // Permet l'interaction mÃªme si le curseur n'est pas sur le point
                    axis: 'x' // Limite l'interaction Ã  l'axe des X (pour sÃ©lectionner la semaine)
                },
                hover: {
                    mode: 'nearest',
                    intersect: false,
                    axis: 'x'
                },
                onTouch: {
                    // C'est l'option clÃ© pour le mobile. 
                    // 'nearest' pour la dÃ©tection du tapotement.
                    mode: 'nearest',
                    intersect: false,
                    axis: 'x'
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.9)',
                        titleColor: '#ffc107',
                        bodyFont: { family: 'Roboto' },
                        borderColor: '#ffc107',
                        borderWidth: 1,
                        callbacks: {
                             // Personnalise l'info bulle pour la moyenne du clan
                            label: function(context) {
                                let label = context.dataset.label || '';

                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(context.parsed.y);
                                }
                                return label;
                            }
                        }
                    }
                }
            },
            plugins: [rankZonesPlugin]
        });

        // --- 5. UI LOGIC ---
        const listContainer = document.getElementById('playerList');
        const versusPanel = document.getElementById('versusPanel');

        function renderList() {
            listContainer.innerHTML = '';
            
            // On boucle sur les datasets des joueurs (en sautant le premier qui est la moyenne du clan)
            chart.data.datasets.slice(1).forEach((ds, i) => { 
                const player = rawData[i];
                const li = document.createElement('li');
                
                let rankClass = '';
                if(i === 0) rankClass = 'rank-1';
                else if(i === 1) rankClass = 'rank-2';
                else if(i === 2) rankClass = 'rank-3';

                li.className = `player-card ${!ds.hidden ? 'active' : 'inactive'}`;
                
                // ðŸ“ˆ HTML TRENDS
                let trendHTML = '';
                if (player.trend > 0) {
                    trendHTML = `<span class="trend-up">+${Math.abs(player.trend).toFixed(1)} ðŸ”¼</span>`;
                } else if (player.trend < 0) {
                    trendHTML = `<span class="trend-down">-${Math.abs(player.trend).toFixed(1)} ðŸ”½</span>`;
                }

                // ðŸ… HTML BADGES
                let badgeHTML = '';
                // 1. ðŸ”¥N Streak
                if (player.streak > 0) badgeHTML += `<span title="SÃ©rie de victoires (${player.streak} semaines)">ðŸ”¥${player.streak}</span>`;
                // 3. ðŸš€ Progression (Ancien On Fire)
                if (player.isProgression) badgeHTML += '<span title="Progression (3 hausses consÃ©cutives)">ðŸš€</span>';
                // 4. ðŸ’¤ AFK
                if (player.isAFK) badgeHTML += '<span title="AFK (Inactif)">ðŸ’¤</span>';


                li.innerHTML = `
                    <span class="rank-num ${rankClass}" style="margin-left:-10px">#${i+1}</span>
                    <div class="player-info">
                        <span class="player-name" style="color:${ds.hidden ? '#aaa' : ds.borderColor}">${ds.label}</span>
                        <span class="player-avg">Moy: ${player.avg} ${trendHTML}</span>
                    </div>
                    <div class="player-badges">${badgeHTML}</div>
                `;

                li.onclick = () => {
                    // L'index dans chart.datasets est i + 1 (Ã  cause de la moyenne du clan Ã  l'index 0)
                    const dsIndex = i + 1;
                    ds.hidden = !ds.hidden;
                    chart.update();
                    renderList();
                    checkVersusMode();
                };
                listContainer.appendChild(li);
            });
        }

        function toggleAll(show) {
            // Boucle Ã  partir de 1 pour ne pas masquer la Moyenne du Clan
            chart.data.datasets.slice(1).forEach(ds => ds.hidden = !show);
            chart.update();
            renderList();
            checkVersusMode();
        }

        // Expose pour les attributs inline onclick (module scope n'est pas global)
        window.toggleAll = toggleAll;

        // --- LOGIQUE MVP & VERSUS ---
        
        function findMVP() {
            // Trouver dynamiquement la derniÃ¨re semaine qui contient au moins une valeur
            let lastWeekIndex = Math.max(0, weeks.length - 1);
            for (let w = weeks.length - 1; w >= 0; w--) {
                if (rawData.some(p => p.scores[w] !== null && p.scores[w] !== undefined)) {
                    lastWeekIndex = w;
                    break;
                }
            }

            let bestScore = -Infinity;
            let bestPlayer = "";

            rawData.forEach(p => {
                const score = p.scores[lastWeekIndex];
                if (score !== null && score !== undefined && score > bestScore) {
                    bestScore = score;
                    bestPlayer = p.name;
                }
            });

            const mvpEl = document.getElementById('mvpName');
            if (bestPlayer) {
                mvpEl.innerText = bestPlayer.toUpperCase() + " (" + bestScore + ")";
            } else {
                mvpEl.innerText = "--";
            }
        }

        function checkVersusMode() {
            // Filtre seulement les datasets des joueurs (index >= 1)
            const visibleDS = chart.data.datasets.slice(1).filter(d => !d.hidden);
            
            if (visibleDS.length === 2) {
                versusPanel.style.display = 'flex';
                
                const p1 = visibleDS[0];
                const p1Data = rawData.find(r => r.name === p1.label);
                
                document.getElementById('p1-name').innerText = p1.label;
                document.getElementById('p1-name').style.color = p1.borderColor;
                document.getElementById('p1-avg').innerText = p1Data.avg;

                const p2 = visibleDS[1];
                const p2Data = rawData.find(r => r.name === p2.label);
                
                document.getElementById('p2-name').innerText = p2.label;
                document.getElementById('p2-name').style.color = p2.borderColor;
                document.getElementById('p2-avg').innerText = p2Data.avg;
                
            } else {
                versusPanel.style.display = 'none';
            }
        }

        // --- ðŸ“¸ EXPORT FUNCTION CORRIGÃ‰E (avec LÃ©gende) ---
        function exportChart() {
            const originalCanvas = document.getElementById('clanChart');
            
            // 1. CrÃ©er un conteneur et un canvas temporaires (cachÃ©s)
            const tempContainer = document.createElement('div');
            tempContainer.style.width = originalCanvas.width + 'px'; // Garde la taille originale
            tempContainer.style.height = originalCanvas.height + 'px';
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px'; // On le met hors Ã©cran
            document.body.appendChild(tempContainer);

            const tempCanvas = document.createElement('canvas');
            tempContainer.appendChild(tempCanvas);

            // 2. CrÃ©er une instance temporaire du Chart, mais AVEC la lÃ©gende
            const tempChart = new Chart(tempCanvas.getContext('2d'), {
                type: 'line',
                data: chart.data, // Utilise les donnÃ©es actuelles (avec les joueurs cachÃ©s/visibles)
                options: {
                    ...chart.options, // Garde toutes les options (Ã©chelles, couleurs, zones, etc.)
                    plugins: {
                        ...chart.options.plugins,
                        legend: { 
                            display: true, // <--- C'EST Ã‡A QUI AJOUTE LA LÃ‰GENDE !
                            labels: { 
                                color: 'white',
                                font: { size: 14 }
                            }
                        }
                    }
                },
                // RÃ©appliquer les plugins nÃ©cessaires, comme les zones de rangs
                plugins: [rankZonesPlugin] 
            });

            // On attend un micro-moment pour que Chart.js rende le graphique avec la lÃ©gende
            setTimeout(() => {
                // CrÃ©er un canvas final avec un fond noir (car le plugin ne dessine que la zone du graph)
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = tempCanvas.width;
                finalCanvas.height = tempCanvas.height;
                const finalCtx = finalCanvas.getContext('2d');
                
                // Dessiner le fond noir
                finalCtx.fillStyle = '#1e1e1e';
                finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                
                // Dessiner le graphique temporaire (avec lÃ©gende) sur le fond noir
                finalCtx.drawImage(tempCanvas, 0, 0);

                // Exportation
                const image = finalCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = image;
                link.download = 'CircledFight_Graph_avec_Legende.png';
                document.body.appendChild(link);
                link.click();
                
                // Nettoyage
                tempChart.destroy(); // DÃ©truire l'instance
                link.remove();
                tempContainer.remove();
                finalCanvas.remove();
            }, 100);
        }

        // Expose export function to global scope for header button onclick
        window.exportChart = exportChart;


        // Lancement
        findMVP();
        renderList();
        checkVersusMode(); 

    </script>
</body>
</html>