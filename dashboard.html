<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circled Fight</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <style>
        .header { position: relative; }
        .hamburger-menu { position: absolute; top: 8px; right: 12px; background: transparent; border: 0; color: var(--codm-yellow); font-size: 1.6rem; padding: 6px; border-radius:6px; z-index:1200; cursor:pointer; }
        .hamburger-menu:focus { outline: 2px solid rgba(255,193,7,0.25); }
        .mobile-hub { position: absolute; right: 12px; top: 44px; width: 86vw; max-width:320px; background:#1b1b1b; border:1px solid #333; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,.6); transform-origin:top right; transform:scale(.95); opacity:0; visibility:hidden; transition:opacity 180ms ease, transform 180ms ease, visibility 180ms; z-index:1199; }
        .mobile-hub.open { transform:scale(1); opacity:1; visibility:visible; }
        .mobile-hub ul { list-style:none; margin:0; padding:8px 0; }
        .mobile-hub li { padding:8px 14px; }
        .mobile-hub a { color:var(--text-main); text-decoration:none; display:block; font-weight:600; }
        .mobile-hub a:hover { color:var(--codm-yellow); }
        .mobile-hub-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.25); opacity:0; visibility:hidden; transition:opacity 180ms ease, visibility 180ms; z-index:1150; }
        .mobile-hub-backdrop.visible { opacity:1; visibility:visible; }
        @media (min-width:900px){ .mobile-hub{ top:54px; width:260px; } }
        /* Sidebar header: place subtitle/meta under the title on a single line */
        .sidebar-header { display: block; padding: 12px 15px; }
        .sidebar-header h3 { margin: 0 0 6px 0; }
        .sidebar-header .meta-line { display: flex; gap: 10px; align-items: center; }
        @media (max-width: 768px) {
    .export-container {
        flex-direction: column;
        align-items: stretch !important;
        width: 100%;
    }
    
    .buttons-row {
        display: flex;
        gap: 10px;
        margin-bottom: 10px;
    }
    
    .export-btn {
        flex: 1;
        width: auto;
    }
    
    .mvp-badge {
        width: 93%;
    }
}
                    
    </style>
</head>
<body>
    
    <div class="header">
        <div>
            <h1>Circled fight <span style="font-size:0.5em; color:white; vertical-align:middle; border:1px solid white; padding:2px 5px; border-radius:3px;">Cf</span></h1>
            <span style="color: var(--text-muted);">Suivi des performances hebdomadaires</span>
            <div style="color: var(--text-muted); font-size:0.8em; margin-top:4px;">Site crÃ©Ã© par CfÂ°3L_Angelos</div>
        </div>

        <div class="export-container">
            <div class="buttons-row">
                <button class="export-btn" onclick="window.location.href='dashboard1.html'">ðŸ“Š Voir Saison 2025</button>
                <button class="export-btn" onclick="exportChart()">ðŸ“¸ Export Graph</button>
            </div>
            <div class="mvp-badge" id="mvpBadge">
                <span>MVP SEMAINE ACTUELLE</span>
                <strong id="mvpName">--</strong>
            </div>
        </div>

        <!-- Hamburger button top-right -->
        <button id="hamburgerMenu" class="hamburger-menu" aria-controls="dashboardMobileHub" aria-expanded="false" aria-label="Ouvrir le menu">â˜°</button>
        <nav id="dashboardMobileHub" class="mobile-hub" aria-hidden="true">
            <ul>
                <li><a href="index.html">Accueil</a></li>
                <li><a href="members.html">Membres du Clan</a></li>
                <li><a href="dashboard.html">Scores MJ</a></li>
                <li><a href="br_dashboard.html">Scores BR</a></li>
                <li><a href="paris.html">Espace Paris</a></li>
                <li><a href="tournament.html">Tournoi du Week-end</a></li>
                <li><a href="1v1.html">1v1</a></li>                
                <li><a href="join.html">Nous Rejoindre</a></li>
            </ul>
        </nav>
        <div id="dashboardMobileHubBackdrop" class="mobile-hub-backdrop" tabindex="-1" aria-hidden="true"></div>
    </div>

    <script>
        // Small hamburger toggle (non-intrusive)
        (function(){
            const btn = document.getElementById('hamburgerMenu');
            const hub = document.getElementById('dashboardMobileHub');
            const backdrop = document.getElementById('dashboardMobileHubBackdrop');
            if(!btn || !hub || !backdrop) return;
            function openHub(){ hub.classList.add('open'); backdrop.classList.add('visible'); btn.setAttribute('aria-expanded','true'); hub.setAttribute('aria-hidden','false'); const first = hub.querySelector('a'); if(first) first.focus(); }
            function closeHub(){ hub.classList.remove('open'); backdrop.classList.remove('visible'); btn.setAttribute('aria-expanded','false'); hub.setAttribute('aria-hidden','true'); btn.focus(); }
            btn.addEventListener('click', ()=>{ const opened = btn.getAttribute('aria-expanded')==='true'; if(opened) closeHub(); else openHub(); });
            backdrop.addEventListener('click', closeHub);
            document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeHub(); });
            hub.addEventListener('click', (e)=>{ if(e.target.tagName==='A') closeHub(); });
        })();
    </script>

    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>CLASSEMENT MJ     </h3>
                <small style="color:#777;" id="sortInfo">Par Total</small>
                <div class="meta-line">
                    <small>Cliquer sur nom pour (dÃ©)masquer sur le graphique</small>
                </div>
                <div style="margin-top: 10px; display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="btn" onclick="changeSortBy('total')" id="sortBtn-total" style="flex: 1; font-size: 0.9em; padding: 6px;">Total</button>
                    <button class="btn" onclick="changeSortBy('kills')" id="sortBtn-kills" style="flex: 1; font-size: 0.9em; padding: 6px;">K</button>
                    <button class="btn" onclick="changeSortBy('assists')" id="sortBtn-assists" style="flex: 1; font-size: 0.9em; padding: 6px;">A</button>
                    <button class="btn" onclick="changeSortBy('wins')" id="sortBtn-wins" style="flex: 1; font-size: 0.9em; padding: 6px;">W</button>
                    <button class="btn" onclick="changeSortBy('svp')" id="sortBtn-svp" style="flex: 1; font-size: 0.9em; padding: 6px;">SVP</button>
                </div>
            </div>
            <ul class="rank-list" id="playerList">
                </ul>
            <div class="controls">
                <button class="btn" onclick="toggleAll(true)">Tout Voir</button>
                <button class="btn" onclick="toggleAll(false)">Masquer</button>
            </div>
        </div>

        <div class="main-content">
            <div class="chart-wrapper">
                <canvas id="clanChart"></canvas>
            </div>
            
            <div class="versus-panel" id="versusPanel">
                <div class="vs-player" id="p1-container">
                    <div class="vs-name" id="p1-name" style="color:cyan">Player 1</div>
                    <div class="vs-score" id="p1-avg">85.5</div>
                    <div class="vs-stat">Moyenne</div>
                </div>
                <div class="vs-icon">VS</div>
                <div class="vs-player" id="p2-container">
                    <div class="vs-name" id="p2-name" style="color:orange">Player 2</div>
                    <div class="vs-score" id="p2-avg">82.0</div>
                    <div class="vs-stat">Moyenne</div>
                </div>
            </div>
        </div>
    </div>

    <div class="legend-panel">
        <h4>LÃ‰GENDE DES BADGES & STATISTIQUES</h4>
        <div class="badges-list">
            <span>ðŸ”¥N : SÃ©rie de victoires (N semaines de participation consÃ©cutive sans absence).</span>
            <span>ðŸš€ Progression : 3 semaines consÃ©cutives de hausse de score.</span>
            <span>ðŸ’¤ AFK : Aucune participation enregistrÃ©e sur les 2 derniÃ¨res semaines.</span>
            <span><strong>K :</strong> Nombre total de kills.</span>
            <span><strong>A :</strong> Nombre total d'assists.</span>
            <span><strong>W :</strong> Nombre total de victoires.</span>
            <span><strong>Calcul du Total :</strong> WÃ—3 + SVPÃ—3 + KÃ—1 + AÃ—0.5</span>
        </div>
    </div>

    <script type="module">
    import { detailedData2026 } from "./js/data2026mj.js";

    // === CONVERSION DES DONNÃ‰ES 2026 EN FORMAT COMPATIBLE ===
    // Calcul : W=3pts, SVP=3pts, K=1pt, A=0.5pt
    
    function convertData2026ToRawData(data2026) {
        // RÃ©cupÃ©rer toutes les sessions disponibles
        const allSessions = new Set();
        Object.values(data2026).forEach(playerData => {
            Object.keys(playerData).forEach(session => allSessions.add(session));
        });
        const weeks = Array.from(allSessions).sort(); // ["S13", "S14", "S15", ...]

        // Convertir chaque joueur
        const rawData = [];
        for (const [playerName, sessions] of Object.entries(data2026)) {
            const scores = weeks.map(week => {
                if (sessions[week]) {
                    const { w, svp, k, a } = sessions[week];
                    // Calcul des points : w*3 + svp*3 + k*1 + a*0.5
                    return (w * 3) + (svp * 3) + (k * 1) + (a * 0.5);
                }
                return null; // Pas de donnÃ©es pour cette semaine
            });

            // Stocker aussi les donnÃ©es brutes pour chaque semaine
            const weeklyDetails = {};
            weeks.forEach((week, index) => {
                if (sessions[week]) {
                    weeklyDetails[week] = sessions[week];
                } else {
                    weeklyDetails[week] = null;
                }
            });

            // Calculer les totaux
            const totalK = Object.values(sessions).reduce((sum, week) => sum + (week.k || 0), 0);
            const totalA = Object.values(sessions).reduce((sum, week) => sum + (week.a || 0), 0);
            const totalW = Object.values(sessions).reduce((sum, week) => sum + (week.w || 0), 0);
            const totalSVP = Object.values(sessions).reduce((sum, week) => sum + (week.svp || 0), 0);

            rawData.push({
                name: playerName,
                scores: scores,
                weeklyDetails: weeklyDetails,
                totalK: totalK,
                totalA: totalA,
                totalW: totalW,
                totalSVP: totalSVP
            });
        }

        return { rawData, weeks };
    }

    // Conversion des donnÃ©es
    const { rawData, weeks } = convertData2026ToRawData(detailedData2026);
    
    // Variable globale pour le tri courant
    let currentSortBy = 'total';

    // Fonction pour recalculer les scores selon le tri
    function recalculateScoresForSort(sortType) {
        rawData.forEach(player => {
            player.scores = weeks.map(week => {
                if (player.weeklyDetails[week]) {
                    const { w, svp, k, a } = player.weeklyDetails[week];
                    if (sortType === 'total') {
                        return (w * 3) + (svp * 3) + (k * 1) + (a * 0.5);
                    } else if (sortType === 'kills') {
                        return k;
                    } else if (sortType === 'assists') {
                        return a;
                    } else if (sortType === 'wins') {
                        return w;
                    } else if (sortType === 'svp') {
                        return svp;
                    }
                }
                return null;
            });
        });
    }

    // Fonction pour calculer l'Ã©cart-type
    function calculateStdDev(scores) {
        const validScores = scores.filter(s => s !== null && s !== undefined);
        if (validScores.length < 2) return Infinity; 
        const mean = validScores.reduce((a, b) => a + b, 0) / validScores.length;
        const variance = validScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validScores.length;
        return Math.sqrt(variance);
    }

    // --- 1. CALCULS, TRENDS & AWARDS (sur toutes les semaines disponibles) ---
    rawData.forEach(player => {
        const validScores = (player.scores || []).filter(s => s !== null && s !== undefined);
        const sum = validScores.reduce((a, b) => a + b, 0);
        player.avg = validScores.length ? (sum / validScores.length).toFixed(1) : 0;

        // lastScore: last non-null within full scores (or 0)
        let lastScore = null;
        for (let i = (player.scores || []).length - 1; i >= 0; i--) {
            if (player.scores[i] !== null && player.scores[i] !== undefined) { lastScore = player.scores[i]; break; }
        }
        player.lastScore = lastScore !== null ? lastScore : 0;

        // ðŸ… BADGES (stdDev calculated on full scores)
        player.stdDev = calculateStdDev(player.scores || []);

        // ðŸ’¤ AFK Check based on the last two full scores
        const lastDataIndex = (player.scores || []).length - 1;
        player.isAFK = (lastDataIndex >= 1) ? (player.scores[lastDataIndex] === null && player.scores[lastDataIndex - 1] === null) : false;

        // ðŸš€ Progression Check (3 hausses consÃ©cutives) within full scores
        let consecutiveIncreases = 0;
        player.isProgression = false;
        for (let i = (player.scores || []).length - 1; i >= 1; i--) {
            const current = player.scores[i];
            const previous = player.scores[i - 1];
            if (current !== null && previous !== null) {
                if (current > previous) {
                    consecutiveIncreases++;
                    if (consecutiveIncreases >= 3) { player.isProgression = true; break; }
                } else if (current < previous) { consecutiveIncreases = 0; }
            }
        }

        // ðŸ”¥N STREAK (Participation consÃ©cutive) - check within full scores
        player.streak = 0;
        for (let i = (player.scores || []).length - 1; i >= 0; i--) {
            if (player.scores[i] !== null && player.scores[i] !== undefined) { player.streak++; }
            else break;
        }

        // ðŸ“ˆ TRENDS (last vs previous) within full scores
        let lastRecordedScore = null;
        let prevRecordedScore = null;
        for (let i = (player.scores || []).length - 1; i >= 0; i--) {
            if (player.scores[i] !== null) {
                if (lastRecordedScore === null) lastRecordedScore = player.scores[i];
                else if (prevRecordedScore === null) { prevRecordedScore = player.scores[i]; break; }
            }
        }
        player.trend = (lastRecordedScore !== null && prevRecordedScore !== null) ? lastRecordedScore - prevRecordedScore : 0;
    });

    // Trier du meilleur au pire (Moyenne)
    rawData.sort((a, b) => b.avg - a.avg);

    // --- 2. MOYENNE DU CLAN (Ligne FantÃ´me) ---
    const clanAverageScores = weeks.map((_, weekIndex) => {
        let weekTotal = 0;
        let weekCount = 0;
        rawData.forEach(player => {
            const score = player.scores[weekIndex];
            if (score !== null && score !== undefined) {
                weekTotal += score;
                weekCount++;
            }
        });
        return weekCount > 0 ? (weekTotal / weekCount) : null;
    });

    function getNeonColor(index) {
        const hues = [180, 300, 60, 120, 20, 250, 0, 330]; 
        const hue = hues[index % hues.length]; 
        const finalHue = hue + (Math.floor(index/hues.length) * 20);
        return `hsl(${finalHue}, 100%, 60%)`;
    }

    // CrÃ©er les datasets des joueurs
    const playerDatasets = rawData.map((player, index) => ({
        label: player.name,
        data: player.scores,
        borderColor: getNeonColor(index),
        backgroundColor: getNeonColor(index),
        borderWidth: 2,
        tension: 0.3,
        pointRadius: 4,
        pointBackgroundColor: '#121212', 
        pointBorderWidth: 2,
        spanGaps: true,
        hidden: index > 4 
    }));

    // Dataset de la moyenne du clan (TOUJOURS en premier)
    const clanAvgDataset = {
        label: "Moyenne du Clan",
        data: clanAverageScores,
        borderColor: 'rgba(255, 255, 255, 0.5)', 
        backgroundColor: 'rgba(255, 255, 255, 0.5)',
        borderWidth: 2,
        borderDash: [5, 5], 
        tension: 0.3,
        pointRadius: 0,
        pointHoverRadius: 0,
        fill: false,
        hidden: false 
    };

    const datasets = [clanAvgDataset, ...playerDatasets]; 

    // --- 3. CONFIG DU GRAPH (Plugin Background) ---
    const rankZonesPlugin = {
        id: 'rankZones',
        beforeDraw: (chart) => {
            const { ctx, chartArea: { top, bottom, left, right, width, height }, scales: { y } } = chart;
            
            const drawZone = (yMin, yMax, color) => {
                const yTop = y.getPixelForValue(yMax);
                const yBottom = y.getPixelForValue(yMin);
                ctx.fillStyle = color;
                ctx.fillRect(left, yTop, width, yBottom - yTop);
            };

            // Dessiner les zones (Backgrounds)
            drawZone(80, 120, 'rgba(0, 230, 118, 0.05)'); // Vert/LÃ©gendaire
            drawZone(40, 80, 'rgba(255, 193, 7, 0.05)');  // Jaune/Pro
            drawZone(0, 40, 'rgba(255, 23, 68, 0.05)');   // Rouge/Rookie
        }
    };

    // --- 4. INITIALISATION CHART ---
    const ctx = document.getElementById('clanChart').getContext('2d');
    const chart = new Chart(ctx, {
        type: 'line',
        data: { labels: weeks, datasets: datasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'nearest',
                intersect: false,
                axis: 'x'
            },
            hover: {
                mode: 'nearest',
                intersect: false,
                axis: 'x'
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    backgroundColor: 'rgba(0,0,0,0.9)',
                    titleColor: '#ffc107',
                    bodyFont: { family: 'Roboto' },
                    borderColor: '#ffc107',
                    borderWidth: 1,
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(context.parsed.y);
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        },
        plugins: [rankZonesPlugin]
    });

    // --- 5. UI LOGIC ---
    const listContainer = document.getElementById('playerList');
    const versusPanel = document.getElementById('versusPanel');

    function renderList() {
        listContainer.innerHTML = '';
        
        chart.data.datasets.slice(1).forEach((ds, i) => { 
            const player = rawData[i];
            const li = document.createElement('li');
            
            let rankClass = '';
            if(i === 0) rankClass = 'rank-1';
            else if(i === 1) rankClass = 'rank-2';
            else if(i === 2) rankClass = 'rank-3';

            li.className = `player-card ${!ds.hidden ? 'active' : 'inactive'}`;
            
            let trendHTML = '';
            if (player.trend > 0) {
                trendHTML = `<span class="trend-up">+${Math.abs(player.trend).toFixed(1)} ðŸ”¼</span>`;
            } else if (player.trend < 0) {
                trendHTML = `<span class="trend-down">-${Math.abs(player.trend).toFixed(1)} ðŸ”½</span>`;
            }

            let badgeHTML = '';
            if (player.streak > 0) badgeHTML += `<span title="SÃ©rie de victoires (${player.streak} semaines)">ðŸ”¥${player.streak}</span>`;
            if (player.isProgression) badgeHTML += '<span title="Progression (3 hausses consÃ©cutives)">ðŸš€</span>';
            if (player.isAFK) badgeHTML += '<span title="AFK (Inactif)">ðŸ’¤</span>';

            let statsHTML = '';
            if (currentSortBy === 'total') {
                statsHTML = `<span class="player-avg">Moy: ${player.avg} | W: ${player.totalW} | SVP: ${player.totalSVP} | K: ${player.totalK} | A: ${player.totalA}</span>`;
            } else if (currentSortBy === 'kills') {
                statsHTML = `<span class="player-avg">K: ${player.totalK} | A: ${player.totalA} | W: ${player.totalW}</span>`;
            } else if (currentSortBy === 'assists') {
                statsHTML = `<span class="player-avg">A: ${player.totalA} | K: ${player.totalK} | W: ${player.totalW}</span>`;            } else if (currentSortBy === 'wins') {
                statsHTML = `<span class="player-avg">W: ${player.totalW} | SVP: ${player.totalSVP} | K: ${player.totalK} | A: ${player.totalA}</span>`;
            } else if (currentSortBy === 'svp') {
                statsHTML = `<span class="player-avg">SVP: ${player.totalSVP} | W: ${player.totalW} | K: ${player.totalK} | A: ${player.totalA}</span>`;            }

            li.innerHTML = `
                <span class="rank-num ${rankClass}" style="margin-left:-10px">#${i+1}</span>
                <div class="player-info">
                    <span class="player-name" style="color:${ds.hidden ? '#aaa' : ds.borderColor}">${ds.label}</span>
                    ${statsHTML}
                    ${trendHTML}
                </div>
                <div class="player-badges">${badgeHTML}</div>
            `;

            li.onclick = () => {
                ds.hidden = !ds.hidden;
                chart.update();
                renderList();
                checkVersusMode();
            };
            listContainer.appendChild(li);
        });
    }

    function toggleAll(show) {
        chart.data.datasets.slice(1).forEach(ds => ds.hidden = !show);
        chart.update();
        renderList();
        checkVersusMode();
    }

    window.toggleAll = toggleAll;

    function changeSortBy(sortType) {
        currentSortBy = sortType;
        
        // Recalculer les scores
        recalculateScoresForSort(sortType);
        
        // Recalculer la moyenne du clan en fonction du nouveau tri
        const newClanAverageScores = weeks.map((_, weekIndex) => {
            let weekTotal = 0;
            let weekCount = 0;
            rawData.forEach(player => {
                const score = player.scores[weekIndex];
                if (score !== null && score !== undefined) {
                    weekTotal += score;
                    weekCount++;
                }
            });
            return weekCount > 0 ? (weekTotal / weekCount) : null;
        });
        clanAvgDataset.data = newClanAverageScores;
        
        // Retrier les donnÃ©es
        if (sortType === 'total') {
            rawData.sort((a, b) => b.avg - a.avg);
            document.getElementById('sortInfo').innerText = 'Par Total';
        } else if (sortType === 'kills') {
            rawData.sort((a, b) => b.totalK - a.totalK);
            document.getElementById('sortInfo').innerText = 'Par Kills';
        } else if (sortType === 'assists') {
            rawData.sort((a, b) => b.totalA - a.totalA);
            document.getElementById('sortInfo').innerText = 'Par Assists';
        } else if (sortType === 'wins') {
            rawData.sort((a, b) => b.totalW - a.totalW);
            document.getElementById('sortInfo').innerText = 'Par Wins';
        } else if (sortType === 'svp') {
            rawData.sort((a, b) => b.totalSVP - a.totalSVP);
            document.getElementById('sortInfo').innerText = 'Par SVP';
        }
        
        // Recalculer les moyennes pour le tri total
        if (sortType === 'total') {
            rawData.forEach(player => {
                const validScores = (player.scores || []).filter(s => s !== null && s !== undefined);
                const sum = validScores.reduce((a, b) => a + b, 0);
                player.avg = validScores.length ? (sum / validScores.length).toFixed(1) : 0;
            });
        }
        
        // Mettre Ã  jour les boutons visuelement
        document.getElementById('sortBtn-total').style.opacity = sortType === 'total' ? '1' : '0.5';
        document.getElementById('sortBtn-kills').style.opacity = sortType === 'kills' ? '1' : '0.5';
        document.getElementById('sortBtn-assists').style.opacity = sortType === 'assists' ? '1' : '0.5';
        document.getElementById('sortBtn-wins').style.opacity = sortType === 'wins' ? '1' : '0.5';
        document.getElementById('sortBtn-svp').style.opacity = sortType === 'svp' ? '1' : '0.5';
        
        // Mettre Ã  jour les datasets du graphique avec les nouveaux scores
        const playerDatasets = rawData.map((player, index) => ({
            label: player.name,
            data: player.scores,
            borderColor: getNeonColor(index),
            backgroundColor: getNeonColor(index),
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4,
            pointBackgroundColor: '#121212', 
            pointBorderWidth: 2,
            spanGaps: true,
            hidden: index > 4 
        }));

        const datasets = [clanAvgDataset, ...playerDatasets];
        chart.data.datasets = datasets;
        
        // RÃ©initialiser la liste et mettre Ã  jour
        renderList();
        chart.update();
        checkVersusMode();
    }

    window.changeSortBy = changeSortBy;

    function findMVP() {
        let lastWeekIndex = Math.max(0, weeks.length - 1);
        for (let w = weeks.length - 1; w >= 0; w--) {
            if (rawData.some(p => p.scores[w] !== null && p.scores[w] !== undefined)) {
                lastWeekIndex = w;
                break;
            }
        }

        let bestScore = -Infinity;
        let bestPlayer = "";

        rawData.forEach(p => {
            const score = p.scores[lastWeekIndex];
            if (score !== null && score !== undefined && score > bestScore) {
                bestScore = score;
                bestPlayer = p.name;
            }
        });

        const mvpEl = document.getElementById('mvpName');
        if (bestPlayer) {
            mvpEl.innerText = bestPlayer.toUpperCase() + " (" + bestScore.toFixed(1) + ")";
        } else {
            mvpEl.innerText = "--";
        }
    }

    function checkVersusMode() {
        const visibleDS = chart.data.datasets.slice(1).filter(d => !d.hidden);
        
        if (visibleDS.length === 2) {
            versusPanel.style.display = 'flex';
            
            const p1 = visibleDS[0];
            const p1Data = rawData.find(r => r.name === p1.label);
            
            document.getElementById('p1-name').innerText = p1.label;
            document.getElementById('p1-name').style.color = p1.borderColor;
            document.getElementById('p1-avg').innerText = p1Data.avg;

            const p2 = visibleDS[1];
            const p2Data = rawData.find(r => r.name === p2.label);
            
            document.getElementById('p2-name').innerText = p2.label;
            document.getElementById('p2-name').style.color = p2.borderColor;
            document.getElementById('p2-avg').innerText = p2Data.avg;
            
        } else {
            versusPanel.style.display = 'none';
        }
    }

    function exportChart() {
        const originalCanvas = document.getElementById('clanChart');
        
        const tempContainer = document.createElement('div');
        tempContainer.style.width = originalCanvas.width + 'px';
        tempContainer.style.height = originalCanvas.height + 'px';
        tempContainer.style.position = 'absolute';
        tempContainer.style.left = '-9999px';
        document.body.appendChild(tempContainer);

        const tempCanvas = document.createElement('canvas');
        tempContainer.appendChild(tempCanvas);

        const tempChart = new Chart(tempCanvas.getContext('2d'), {
            type: 'line',
            data: chart.data,
            options: {
                ...chart.options,
                plugins: {
                    ...chart.options.plugins,
                    legend: { 
                        display: true,
                        labels: { 
                            color: 'white',
                            font: { size: 14 }
                        }
                    }
                }
            },
            plugins: [rankZonesPlugin] 
        });

        setTimeout(() => {
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = tempCanvas.width;
            finalCanvas.height = tempCanvas.height;
            const finalCtx = finalCanvas.getContext('2d');
            
            finalCtx.fillStyle = '#1e1e1e';
            finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            
            finalCtx.drawImage(tempCanvas, 0, 0);

            const image = finalCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = image;
            link.download = 'CircledFight_Graph_Saison2026.png';
            document.body.appendChild(link);
            link.click();
            
            tempChart.destroy();
            link.remove();
            tempContainer.remove();
            finalCanvas.remove();
        }, 100);
    }

    window.exportChart = exportChart;

    // Lancement
    findMVP();
    renderList();
    checkVersusMode();
    
    // Initialiser l'apparence des boutons
    document.getElementById('sortBtn-total').style.opacity = '1';
    document.getElementById('sortBtn-kills').style.opacity = '0.5';
    document.getElementById('sortBtn-assists').style.opacity = '0.5';
    document.getElementById('sortBtn-wins').style.opacity = '0.5';
    document.getElementById('sortBtn-svp').style.opacity = '0.5'; 

</script>

<footer style="text-align:center; margin:30px 0 10px 0; color:#888; font-size:0.95em; letter-spacing:0.5px;">
    RÃ©alisÃ© par <strong>Angelos</strong> &mdash; <a href="https://github.com/P4lbL0?tab=repositories" target="_blank" style="color:#ffc107; text-decoration:underline;">Voir mes autres projets</a>
</footer>