<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Paris - Circled Fight</title>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&family=Rajdhani:wght@300;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/paris.css">
    
    <style>
        
    </style>
</head>
<body>
    
    <div class="prevention-banner">
        <span class="warning-icon">⚠</span>
        <span>JOUER COMPORTE DES RISQUES : ENDETTEMENT, DÉPENDANCE... APPELEZ LE 09 74 75 13 13.</span>
    </div>

    <div class="header">
        <div>
            <h1>Circled <span>Fight</span></h1>
            <div class="sub-header">ESPACE PARIS & CLASSEMENT</div>
        </div>
        <div class="export-container">
            <span id="adminLink" style="display:none; margin-right: 5px;">
                <a href="admin.html" class="btn-nav btn-admin">CMD</a>
            </span>
            <a href="index.html" class="btn-nav">QUITTER</a>
        </div>
    </div>

    <main>
        <div id="authSection" class="login-wrapper">
            <h2 id="authTitle" style="color: white; font-family: 'Orbitron'; margin: 0 0 10px 0; text-align: center;">IDENTIFICATION</h2>
            <p id="authSub" style="color:#666; margin-bottom:30px; text-align: center; font-size: 0.9rem;">Accès au réseau de paris</p>
            
            <div id="errorMessage" class="error-msg">Erreur ici</div>
            
            <div class="input-group">
                <label>IDENTIFIANT (PSEUDO)</label>
                <input type="text" id="pseudoInput" class="input-field" placeholder="Angelos...">
            </div>
            <div class="input-group">
                <label>CODE D'ACCÈS (MDP)</label>
                <input type="password" id="mdpInput" class="input-field" placeholder="••••••">
            </div>
            
            <button id="btnAction" class="action-btn">CONNEXION</button>
            <p style="text-align: center; margin-top: 20px; font-size: 0.8rem; color: #666; cursor: pointer; text-decoration: underline;" id="toggleMode"></p>
        </div>

        <div id="bettingSection" class="dashboard-paris">
            <div class="user-card">
                <div>
                    <div id="displayPseudo" class="user-pseudo">Chargement...</div>
                    <small style="color: var(--accent-red); font-family: 'Orbitron';">STATUS: EN LIGNE</small>
                </div>
                <div class="cf-points">
                    <span id="userPoints">---</span> <span style="font-size:0.4em; color: #fff;">CF</span>
                </div>
            </div>
            
            <div id="matchListContainer">
                <h3 style="margin-bottom: 20px; color: white; font-family: 'Orbitron'; border-left: 3px solid var(--accent-red); padding-left: 10px;">CLASSEMENTS EN COURS</h3>
                <div id="openMatchList">
                    <p style="color: #666; text-align: center; margin-top: 50px;">Scan des données en cours...</p>
                </div>
            </div>
            
            <button id="btnLogout" class="btn-nav" style="width: 100%; margin-top: 40px; text-align: center; display: block;">DÉCONNEXION SYSTÈME</button>
        </div>
    </main>

    <script type="module">
        import { auth, db, doc, getDoc, setDoc, updateDoc, collection, query, where, getDocs, onAuthStateChanged, signOut } from './js/firebase.js';
        import { createUserWithEmailAndPassword, signInWithEmailAndPassword } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        
        // ⚠️ IMPORT DES NOUVEAUX CALCULATEURS DE COTES (TEMPS RÉEL)
        import { getAllPlayersWithStats, calculateRealTimeOdds } from './js/data-utils.js';
        
        const ADMIN_UID = "CZ0UeiyrPNVufTVnnYSH4YTnGP13"; 

        const authSection = document.getElementById('authSection');
        const bettingSection = document.getElementById('bettingSection');
        const pseudoInput = document.getElementById('pseudoInput');
        const mdpInput = document.getElementById('mdpInput');
        const btnAction = document.getElementById('btnAction');
        const toggleMode = document.getElementById('toggleMode');
        const authTitle = document.getElementById('authTitle');
        const errorMsg = document.getElementById('errorMessage');
        const adminLink = document.getElementById('adminLink');
        const openMatchList = document.getElementById('openMatchList');

        let isLoginMode = true;
        let currentUserData = null; 
        
        window.userPredictions = {}; 
        window.matchDataCache = {}; 
        
        // On charge les stats de tout le monde UNE SEULE FOIS pour éviter de recalculer en boucle
        const globalStats = getAllPlayersWithStats();

        // --- Fonctions d'authentification ---
        toggleMode.addEventListener('click', () => {
            isLoginMode = !isLoginMode;
            errorMsg.style.display = 'none';
            if (isLoginMode) {
                authTitle.innerText = "IDENTIFICATION";
                btnAction.innerText = "CONNEXION";
                toggleMode.innerText = "Pas de compte ? S'enrôler";
            } else {
                authTitle.innerText = "ENRÔLEMENT";
                btnAction.innerText = "S'INSCRIRE (+100 CF)";
                toggleMode.innerText = "Déjà soldat ? Connexion";
            }
        });

        btnAction.addEventListener('click', async () => {
            const pseudo = pseudoInput.value.trim();
            const mdp = mdpInput.value;
            if (pseudo.length < 1 || mdp.length < 1) { showError("Pseudo > 3 car. et MDP > 6 car. requis."); return; }
            const fakeEmail = pseudo.toLowerCase().replace(/\s/g, '') + "@circledfight.clan";

            try {
                if (isLoginMode) {
                    await signInWithEmailAndPassword(auth, fakeEmail, mdp);
                } else {
                    const userCredential = await createUserWithEmailAndPassword(auth, fakeEmail, mdp);
                    const user = userCredential.user;
                    await setDoc(doc(db, "users", user.uid), {
                        pseudo: pseudo, 
                        email: fakeEmail,
                        cfPoints: 100, 
                        joinedAt: new Date()
                    });
                }
            } catch (error) {
                console.error(error);
                if (error.code === 'auth/email-already-in-use') showError("Ce pseudo est déjà utilisé.");
                else if (error.code === 'auth/invalid-credential') showError("Accès refusé. Vérifiez vos infos.");
                else showError("Erreur système : " + error.message);
            }
        });

        function showError(msg) {
            errorMsg.innerText = msg;
            errorMsg.style.display = 'block';
        }

        document.getElementById('btnLogout').addEventListener('click', () => {
            signOut(auth).then(() => location.reload());
        });
        
        // --- LOGIQUE DE PARI CLASSEMENT ---
        
        async function loadOpenMatches(userId) {
            openMatchList.innerHTML = '<p style="color: #666; text-align: center;">Synchronisation des données...</p>';
            
            const q = query(collection(db, "matches"), where("status", "==", "open"), where("type", "==", "ranking"));
            const snapshot = await getDocs(q);
            
            if (snapshot.empty) {
                openMatchList.innerHTML = '<div style="padding: 20px; border: 1px dashed #444; text-align: center; color: #666;">Aucun événement ouvert pour le moment.</div>';
                return;
            }

            let html = '';
            for (const docMatch of snapshot.docs) {
                const match = docMatch.data();
                const matchId = docMatch.id;
                const numPlayers = Object.keys(match.players).length;
                
                window.matchDataCache[matchId] = match;

                const rankOptions = Array.from({length: numPlayers}, (_, i) => `<option value="${i+1}">Rang #${i+1}</option>`).join('');

                // Vérifier si l'utilisateur a déjà parié
                const betQuery = query(collection(db, "bets"), 
                    where("matchId", "==", matchId),
                    where("userId", "==", userId)
                );
                const betSnapshot = await getDocs(betQuery);
                const hasUserBet = !betSnapshot.empty;
                const userBet = hasUserBet ? betSnapshot.docs[0].data() : null;
                
                if (hasUserBet) {
                    let summaryHtml = `<p style="font-weight: bold; margin-bottom: 10px; color:#aaa;">RÉCAPITULATIF DE MISSION :</p>`;
                    for (const [player, rank] of Object.entries(userBet.prediction)) {
                        const cote = userBet.odds[player][rank] ?? 1.00; 
                        summaryHtml += `<div style="display:flex; justify-content:space-between; border-bottom:1px solid #333; padding:5px 0;"><span style="color:white;">${player}</span> <span style="color:var(--codm-yellow);">Rang ${rank} (x${cote.toFixed(2)})</span></div>`;
                    }

                    html += `
                        <div class="ranking-card" style="border-left: 4px solid #4CAF50;">
                            <div class="card-header">
                                <h4>✅ PARI VALIDÉ</h4>
                                <span style="font-size:0.8rem; color:#4CAF50;">MISE: ${userBet.amount} CF</span>
                            </div>
                            <div class="card-body">
                                ${summaryHtml}
                                <div style="margin-top:15px; text-align:center; font-size:0.8rem; color:#666;">Attente des résultats finaux...</div>
                            </div>
                        </div>
                    `;
                    continue;
                }
                
                // Formulaire de prédiction
                html += `
                    <div class="ranking-card" id="card-${matchId}">
                        <div class="card-header">
                            <h4>PRÉDICTION CLASSEMENT (TOP ${numPlayers})</h4>
                        </div>
                        <div class="card-body">
                            <p style="color: #888; font-size: 0.85rem; margin-bottom: 15px;">Assignez un rang final à chaque joueur. Laissez vide si incertain.</p>

                            <div class="player-ranking-grid" id="ranking-grid-${matchId}">
                `;

                // Liste des joueurs
                for (const playerName in match.players) {
                    // CALCUL TEMPS RÉEL DE LA COTE PAR DÉFAUT (RANG 1)
                    const playerStats = globalStats.find(p => p.name === playerName);
                    let defaultCote = 1.01;
                    if(playerStats) {
                        defaultCote = calculateRealTimeOdds(playerStats, 1, numPlayers);
                    }

                    html += `
                        <div class="player-ranking-row">
                            <span class="player-name">${playerName}</span>
                            <select id="select-${matchId}-${playerName}" data-player="${playerName}" onchange="updateBetSummary('${matchId}')">
                                <option value="">-- Aucun --</option>
                                ${rankOptions}
                            </select>
                            <div class="current-cote" id="cote-${matchId}-${playerName}">Cote: <span>x${defaultCote.toFixed(2)}</span></div>
                        </div>
                    `;
                }

                html += `
                            </div>
                            
                            <div class="bet-summary">
                                <div id="selected-bets-${matchId}" style="margin-bottom: 15px; font-size: 0.9em; color: #aaa; font-style: italic;">Aucune sélection active.</div>
                                
                                <div class="input-group" style="margin-bottom:0;">
                                    <label style="color:white;">MISE TOTALE (Max: ${currentUserData.cfPoints} CF)</label>
                                    <input type="number" id="amount-${matchId}" class="input-field" min="10" max="${currentUserData.cfPoints}" placeholder="Montant..." style="border: 1px solid var(--codm-yellow);">
                                </div>
                            </div>
                            
                            <p class="error-msg" id="msg-${matchId}" style="text-align:center; margin-top:10px;"></p>
                            <button class="action-btn" style="margin-top: 10px;" onclick="placeRankingBet('${matchId}')">CONFIRMER ORDRE</button>
                        </div>
                    </div>
                `;
            }
            openMatchList.innerHTML = html;
        }
        
        window.updateBetSummary = (matchId) => {
            const card = document.getElementById(`card-${matchId}`);
            const amount = parseInt(document.getElementById(`amount-${matchId}`).value) || 0;
            const msgElement = document.getElementById(`msg-${matchId}`);
            const selectedBetsDiv = document.getElementById(`selected-bets-${matchId}`);

            const selectedRanks = {};
            const selectedRankElements = card.querySelectorAll('select[data-player]');
            let summaryText = '';
            
            selectedRankElements.forEach(select => {
                const playerName = select.getAttribute('data-player');
                const selectedRank = parseInt(select.value);
                const coteElement = document.getElementById(`cote-${matchId}-${playerName}`);
                const numPlayers = Object.keys(matchDataCache[matchId].players).length;
                
                // Récupération des stats du joueur spécifique
                const playerStats = globalStats.find(p => p.name === playerName);
                
                if (selectedRank && playerStats) {
                    // CALCUL TEMPS RÉEL : On calcule la cote pour ce rang spécifique
                    const cote = calculateRealTimeOdds(playerStats, selectedRank, numPlayers);
                    
                    coteElement.innerHTML = `Cote: <span>x${cote.toFixed(2)}</span>`;
                    selectedRanks[playerName] = selectedRank;
                    summaryText += `<span style="color:var(--codm-yellow)">${playerName}</span> ➝ Rang ${selectedRank} (x${cote.toFixed(2)})<br>`;
                } else if (playerStats) {
                    // Retour à la cote par défaut (Rang 1)
                    const defaultCote = calculateRealTimeOdds(playerStats, 1, numPlayers);
                    coteElement.innerHTML = `Cote: <span>x${defaultCote.toFixed(2)}</span>`;
                }
            });
            
            selectedBetsDiv.innerHTML = summaryText || "Aucune sélection active.";

            const ranksSelected = Object.values(selectedRanks);
            const uniqueRanks = new Set(ranksSelected);
            
            if (ranksSelected.length > 1 && ranksSelected.length !== uniqueRanks.size) {
                 msgElement.style.display = 'block';
                 msgElement.innerText = "ATTENTION: Impossible de mettre deux joueurs au même rang !";
            } else {
                 msgElement.style.display = 'none';
                 msgElement.innerText = "";
            }
            
            window.userPredictions[matchId] = {
                prediction: selectedRanks,
                amount: amount
            };
        };
        
        window.placeRankingBet = async (matchId) => {
            const predictionData = window.userPredictions[matchId];
            const msgElement = document.getElementById(`msg-${matchId}`);
            msgElement.style.display = 'block';
            
            if (!predictionData) {
                msgElement.innerText = "Sélection vide.";
                return;
            }
            
            const selectedPredictions = predictionData.prediction;
            const numPredictions = Object.keys(selectedPredictions).length;
            const amount = parseInt(document.getElementById(`amount-${matchId}`).value);

            if (numPredictions === 0) { msgElement.innerText = "Sélectionnez au moins un joueur."; return; }
            if (isNaN(amount) || amount < 10) { msgElement.innerText = "Mise minimum : 10 CF."; return; }
            if (amount > currentUserData.cfPoints) { msgElement.innerText = "Fonds insuffisants."; return; }
            
            const ranksSelected = Object.values(selectedPredictions);
            const uniqueRanks = new Set(ranksSelected);
            if (ranksSelected.length > 1 && ranksSelected.length !== uniqueRanks.size) {
                 msgElement.innerText = "Erreur: Rangs dupliqués détectés.";
                 return;
            }

            try {
                const newPoints = currentUserData.cfPoints - amount;
                await updateDoc(doc(db, "users", auth.currentUser.uid), { cfPoints: newPoints });

                const matchData = matchDataCache[matchId];
                const numPlayers = Object.keys(matchData.players).length;
                const oddsAtBet = {};
                
                // ON FIGE LES COTES ICI AU MOMENT DU PAIEMENT
                for (const player in selectedPredictions) {
                      const rank = selectedPredictions[player];
                      const playerStats = globalStats.find(p => p.name === player);
                      
                      if(playerStats) {
                          oddsAtBet[player] = {};
                          // On recalcule une dernière fois pour être sûr
                          const finalCote = calculateRealTimeOdds(playerStats, rank, numPlayers);
                          oddsAtBet[player][rank] = finalCote;
                      }
                }

                await setDoc(doc(db, "bets", `BET-${auth.currentUser.uid}-${matchId}`), {
                    matchId: matchId,
                    userId: auth.currentUser.uid,
                    amount: amount,
                    isSettled: false,
                    prediction: selectedPredictions,
                    odds: oddsAtBet, // On stocke les cotes calculées
                    betTime: new Date().toISOString()
                });

                msgElement.className = "success-msg";
                msgElement.innerText = "Pari enregistré avec succès.";
                currentUserData.cfPoints = newPoints;
                document.getElementById('userPoints').innerText = newPoints;
                setTimeout(() => loadOpenMatches(auth.currentUser.uid), 1500);

            } catch (e) {
                console.error("Erreur:", e);
                msgElement.innerText = "Erreur système critique.";
            }
        };

        // --- ÉCOUTEUR D'ÉTAT ---
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                authSection.style.display = 'none';
                bettingSection.style.display = 'block';
                
                if (user.uid === ADMIN_UID) {
                    adminLink.style.display = 'inline-block';
                }

                const userRef = doc(db, "users", user.uid);
                const userSnap = await getDoc(userRef);

                if (userSnap.exists()) {
                    currentUserData = userSnap.data();
                    document.getElementById('displayPseudo').innerText = currentUserData.pseudo;
                    document.getElementById('userPoints').innerText = currentUserData.cfPoints;
                    loadOpenMatches(user.uid);
                }
            } else {
                authSection.style.display = 'block';
                bettingSection.style.display = 'none';
                adminLink.style.display = 'none';
            }
        });

    </script>
</body>
</html>