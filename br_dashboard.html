<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circled Fight - Scores Battle Royale</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto:wght@300;400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="css/style.css"> 
    <style>
        .header { position: relative; }
        .hamburger-menu { position: absolute; top: 8px; right: 12px; background: transparent; border: 0; color: var(--codm-yellow); font-size: 1.6rem; padding: 6px; border-radius:6px; z-index:1200; cursor:pointer; }
        .hamburger-menu:focus { outline: 2px solid rgba(255,193,7,0.25); }
        .mobile-hub { position: absolute; right: 12px; top: 44px; width: 86vw; max-width:320px; background:#1b1b1b; border:1px solid #333; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,.6); transform-origin:top right; transform:scale(.95); opacity:0; visibility:hidden; transition:opacity 180ms ease, transform 180ms ease, visibility 180ms; z-index:1199; }
        .mobile-hub.open { transform:scale(1); opacity:1; visibility:visible; }
        .mobile-hub ul { list-style:none; margin:0; padding:8px 0; }
        .mobile-hub li { padding:8px 14px; }
        .mobile-hub a { color:var(--text-main); text-decoration:none; display:block; font-weight:600; }
        .mobile-hub a:hover { color:var(--codm-yellow); }
        .mobile-hub-backdrop { position:fixed; inset:0; background:rgba(0,0,0,0.25); opacity:0; visibility:hidden; transition:opacity 180ms ease, visibility 180ms; z-index:1150; }
        .mobile-hub-backdrop.visible { opacity:1; visibility:visible; }
        @media (min-width:900px){ .mobile-hub{ top:54px; width:260px; } }
        /* Sidebar header: place subtitle/meta under the title on a single line */
        .sidebar-header { display: block; padding: 12px 15px; }
        .sidebar-header h3 { margin: 0 0 6px 0; }
        .sidebar-header .meta-line { display: flex; gap: 10px; align-items: center; }
    </style>
</head>
<body>
    
    <div class="header">
        <div>
            <h1>Circled fight <span style="font-size:0.5em; color:white; vertical-align:middle; border:1px solid white; padding:2px 5px; border-radius:3px;">Cf</span></h1>
            <span style="color: var(--text-muted);">Suivi des performances hebdomadaires</span>
            <div style="color: var(--text-muted); font-size:0.8em; margin-top:4px;">Site crÃ©Ã© par CfÂ°3L_Angelos</div>
        </div>

        <div class="export-container">
            <button class="export-btn" onclick="window.location.href='br_dashboard1.html'">ðŸ“Š Voir Saison 2025</button>
            <button class="export-btn" onclick="exportChart()">ðŸ“¸ Export Graph</button>
            <div class="mvp-badge" id="mvpBadge">
                <span>MVP SEMAINE ACTUELLE</span>
                <strong id="mvpName">--</strong>
            </div>
        </div>

        <!-- Hamburger button top-right -->
        <button id="hamburgerMenu" class="hamburger-menu" aria-controls="dashboardMobileHub" aria-expanded="false" aria-label="Ouvrir le menu">â˜°</button>
        <nav id="dashboardMobileHub" class="mobile-hub" aria-hidden="true">
            <ul>
                <li><a href="index.html">Accueil</a></li>
                <li><a href="members.html">Membres du Clan</a></li>
                <li><a href="dashboard.html">Scores MJ</a></li>
                <li><a href="br_dashboard.html">Scores BR</a></li>
                <li><a href="paris.html">Espace Paris</a></li>
                <li><a href="tournament.html">Tournoi du Week-end</a></li>
                <li><a href="1v1.html">1v1</a></li>                
                <li><a href="join.html">Nous Rejoindre</a></li>
            </ul>
        </nav>
        <div id="dashboardMobileHubBackdrop" class="mobile-hub-backdrop" tabindex="-1" aria-hidden="true"></div>
    </div>

    <script>
        // Small hamburger toggle (rÃ©utilisÃ©)
        (function(){
            const btn = document.getElementById('hamburgerMenu');
            const hub = document.getElementById('dashboardMobileHub');
            const backdrop = document.getElementById('dashboardMobileHubBackdrop');
            if(!btn || !hub || !backdrop) return;
            function openHub(){ hub.classList.add('open'); backdrop.classList.add('visible'); btn.setAttribute('aria-expanded','true'); hub.setAttribute('aria-hidden','false'); const first = hub.querySelector('a'); if(first) first.focus(); }
            function closeHub(){ hub.classList.remove('open'); backdrop.classList.remove('visible'); btn.setAttribute('aria-expanded','false'); hub.setAttribute('aria-hidden','true'); btn.focus(); }
            btn.addEventListener('click', ()=>{ const opened = btn.getAttribute('aria-expanded')==='true'; if(opened) closeHub(); else openHub(); });
            backdrop.addEventListener('click', closeHub);
            document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeHub(); });
            hub.addEventListener('click', (e)=>{ if(e.target.tagName==='A') closeHub(); });
        })();
    </script>

    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>CLASSEMENT BR     </h3>
                <small style="color:#777;">Par Moyenne</small>
                <div class="meta-line">
                    <small>Cliquer sur nom pour (dÃ©)masquer sur le graphique</small>
                    
                </div>
            </div>
            <ul class="rank-list" id="playerList">
                </ul>
            <div class="controls">
                <button class="btn" onclick="toggleAll(true)">Tout Voir</button>
                <button class="btn" onclick="toggleAll(false)">Masquer</button>
            </div>
        </div>

        <div class="main-content">
            <div>
                <div class="chart-wrapper">
                    <canvas id="brClanChart"></canvas>
                </div>
                <div class="versus-panel" id="brVersusPanel">
                    <div class="vs-player" id="br-p1-container">
                        <div class="vs-name" id="br-p1-name" style="color:#00bcd4">Player 1</div>
                        <div class="vs-score" id="br-p1-avg">--</div>
                        <div class="vs-stat">Moyenne</div>
                    </div>
                    <div class="vs-icon">VS</div>
                    <div class="vs-player" id="br-p2-container">
                        <div class="vs-name" id="br-p2-name" style="color:#00e676">Player 2</div>
                        <div class="vs-score" id="br-p2-avg">--</div>
                        <div class="vs-stat">Moyenne</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="legend-panel" style="color: #777; text-align: center; padding: 15px;">
        <small>Ce tableau de bord est dÃ©diÃ© au Battle Royale. Les badges de statut ne sont pas appliquÃ©s ici.</small>
    </div>

    <script type="module">
    // Importation UNIQUEMENT des donnÃ©es BR
    import { weeks, brData } from "./js/data2026br.js";

    // Restrict charts and averages to the last N weeks
    const RECENT_N = 10;
    const recentStart = Math.max(0, weeks.length - RECENT_N);
    const recentWeeks = weeks.slice(recentStart);

    // Fonction pour calculer l'Ã©cart-type
        function calculateStdDev(scores) {
            const validScores = scores.filter(s => s !== null && s !== undefined);
            if (validScores.length < 2) return Infinity; 
            const mean = validScores.reduce((a, b) => a + b, 0) / validScores.length;
            const variance = validScores.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / validScores.length;
            return Math.sqrt(variance);
        }

        // --- 1. CALCULS, TRENDS & AWARDS ---
        brData.forEach(player => {
            const recentScores = (player.scores && player.scores.length) ? player.scores.slice(recentStart) : [];
            const validScores = recentScores.filter(s => s !== null && s !== undefined);
            const sum = validScores.reduce((a, b) => a + b, 0);
            player.avg = validScores.length ? Number((sum / validScores.length).toFixed(1)) : 0;
            player.lastScore = recentScores.length ? (recentScores[recentScores.length - 1] || 0) : 0;

            // ðŸ… BADGES
            player.stdDev = calculateStdDev(recentScores);

            // ðŸ’¤ AFK Check (Absence sur les 2 derniÃ¨res semaines de data)
            const lastDataIndex = recentScores.length - 1;
            player.isAFK = (recentScores.length >= 2 && recentScores[lastDataIndex] === null && recentScores[lastDataIndex - 1] === null);

            // ðŸš€ Progression Check (3 hausses consÃ©cutives parmi les scores enregistrÃ©s)
            let consecutiveIncreases = 0;
            player.isOnFire = false;
            player.isProgression = false;
            for (let i = recentScores.length - 1; i >= 1; i--) {
                const current = recentScores[i];
                const previous = recentScores[i - 1];

                if (current !== null && previous !== null) {
                    if (current > previous) {
                        consecutiveIncreases++;
                        if (consecutiveIncreases >= 3) {
                            player.isProgression = true;
                            break;
                        }
                    } else if (current < previous) {
                        consecutiveIncreases = 0;
                    }
                }
            }

            // ðŸ”¥N STREAK (Participation consÃ©cutive)
            player.streak = 0;
            for (let i = recentScores.length - 1; i >= 0; i--) {
                if (recentScores[i] !== null && recentScores[i] !== undefined) {
                    player.streak++;
                } else {
                    break;
                }
            }

            // ðŸ“ˆ TRENDS (Dernier score enregistrÃ© vs prÃ©cÃ©dent) dans recentScores
            let lastRecordedScore = null;
            let prevRecordedScore = null;
            for (let i = recentScores.length - 1; i >= 0; i--) {
                if (recentScores[i] !== null) {
                    if (lastRecordedScore === null) {
                        lastRecordedScore = recentScores[i];
                    } else if (prevRecordedScore === null) {
                        prevRecordedScore = recentScores[i];
                        break;
                    }
                }
            }
            player.trend = lastRecordedScore !== null && prevRecordedScore !== null ? lastRecordedScore - prevRecordedScore : 0;
        });




        // Trier du meilleur au pire (Moyenne)
        brData.sort((a, b) => b.avg - a.avg);

        // --- 2. MOYENNE DU CLAN (Ligne FantÃ´me) sur les recentWeeks ---
        const clanAverageScores = recentWeeks.map((_, idx) => {
            const weekIndex = recentStart + idx;
            let weekTotal = 0;
            let weekCount = 0;
            brData.forEach(player => {
                const score = (player.scores && player.scores.length > weekIndex) ? player.scores[weekIndex] : null;
                if (score !== null && score !== undefined) { weekTotal += score; weekCount++; }
            });
            return weekCount > 0 ? (weekTotal / weekCount) : null;
        });

        function getNeonColor(index) {
            const hues = [180, 300, 60, 120, 20, 250, 0, 330]; 
            const hue = hues[index % hues.length]; 
            const finalHue = hue + (Math.floor(index/hues.length) * 20);
            return `hsl(${finalHue}, 100%, 60%)`;
        }

        // CrÃ©er les datasets des joueurs
        const playerDatasets = brData.map((player, index) => ({
            label: player.name,
            data: (player.scores && player.scores.length) ? player.scores.slice(recentStart) : [],
            borderColor: getNeonColor(index),
            backgroundColor: getNeonColor(index),
            borderWidth: 2,
            tension: 0.3,
            pointRadius: 4,
            pointBackgroundColor: '#121212', 
            pointBorderWidth: 2,
            spanGaps: true,
            hidden: index > 4 
        }));

        // Dataset de la moyenne du clan (TOUJOURS en premier)
        const clanAvgDataset = {
            label: "Moyenne du Clan",
            data: clanAverageScores,
            borderColor: 'rgba(255, 255, 255, 0.5)', 
            backgroundColor: 'rgba(255, 255, 255, 0.5)',
            borderWidth: 2,
            borderDash: [5, 5], 
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 0,
            fill: false,
            hidden: false 
        };

        const datasets = [clanAvgDataset, ...playerDatasets]; 

        // --- 3. CONFIG DU GRAPH (Plugin Background) ---
        const rankZonesPlugin = {
            id: 'rankZones',
            beforeDraw: (chart) => {
                const { ctx, chartArea: { top, bottom, left, right, width, height }, scales: { y } } = chart;
                
                const drawZone = (yMin, yMax, color) => {
                    const yTop = y.getPixelForValue(yMax);
                    const yBottom = y.getPixelForValue(yMin);
                    ctx.fillStyle = color;
                    ctx.fillRect(left, yTop, width, yBottom - yTop);
                };

                // Dessiner les zones (Backgrounds)
                drawZone(80, 120, 'rgba(0, 230, 118, 0.05)'); // Vert/LÃ©gendaire
                drawZone(40, 80, 'rgba(255, 193, 7, 0.05)');  // Jaune/Pro
                drawZone(0, 40, 'rgba(255, 23, 68, 0.05)');   // Rouge/Rookie
            }
        };

        // --- 4. INITIALISATION CHART ---
        const ctx = document.getElementById('brClanChart').getContext('2d');
        const chart = new Chart(ctx, {
            type: 'line',
            data: { labels: recentWeeks, datasets: datasets },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                // --- NOUVEAU CODE ---
                interaction: {
                    mode: 'nearest', // Cherche le point le plus proche
                    intersect: false, // Permet l'interaction mÃªme si le curseur n'est pas sur le point
                    axis: 'x' // Limite l'interaction Ã  l'axe des X (pour sÃ©lectionner la semaine)
                },
                hover: {
                    mode: 'nearest',
                    intersect: false,
                    axis: 'x'
                },
                onTouch: {
                    // C'est l'option clÃ© pour le mobile. 
                    // 'nearest' pour la dÃ©tection du tapotement.
                    mode: 'nearest',
                    intersect: false,
                    axis: 'x'
                },
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        backgroundColor: 'rgba(0,0,0,0.9)',
                        titleColor: '#ffc107',
                        bodyFont: { family: 'Roboto' },
                        borderColor: '#ffc107',
                        borderWidth: 1,
                        callbacks: {
                             // Personnalise l'info bulle pour la moyenne du clan
                            label: function(context) {
                                let label = context.dataset.label || '';

                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += new Intl.NumberFormat('fr-FR', { minimumFractionDigits: 1, maximumFractionDigits: 1 }).format(context.parsed.y);
                                }
                                return label;
                            }
                        }
                    }
                }
            },
            plugins: [rankZonesPlugin]
        });

        // --- 5. UI LOGIC ---
        const listContainer = document.getElementById('playerList');
        const versusPanel = document.getElementById('brVersusPanel');

        function renderList() {
            listContainer.innerHTML = '';
            
            // On boucle sur les datasets des joueurs (en sautant le premier qui est la moyenne du clan)
            chart.data.datasets.slice(1).forEach((ds, i) => { 
                const player = brData[i];
                const li = document.createElement('li');
                
                let rankClass = '';
                if(i === 0) rankClass = 'rank-1';
                else if(i === 1) rankClass = 'rank-2';
                else if(i === 2) rankClass = 'rank-3';

                li.className = `player-card ${!ds.hidden ? 'active' : 'inactive'}`;
                
                // ðŸ“ˆ HTML TRENDS
                let trendHTML = '';
                if (player.trend > 0) {
                    trendHTML = `<span class="trend-up">+${Math.abs(player.trend).toFixed(1)} ðŸ”¼</span>`;
                } else if (player.trend < 0) {
                    trendHTML = `<span class="trend-down">-${Math.abs(player.trend).toFixed(1)} ðŸ”½</span>`;
                }

                // ðŸ… HTML BADGES
                let badgeHTML = '';
                // 1. ðŸ”¥N Streak
                if (player.streak > 0) badgeHTML += `<span title="SÃ©rie de victoires (${player.streak} semaines)">ðŸ”¥${player.streak}</span>`;
                // 3. ðŸš€ Progression (Ancien On Fire)
                if (player.isProgression) badgeHTML += '<span title="Progression (3 hausses consÃ©cutives)">ðŸš€</span>';
                // 4. ðŸ’¤ AFK
                if (player.isAFK) badgeHTML += '<span title="AFK (Inactif)">ðŸ’¤</span>';


                li.innerHTML = `
                    <span class="rank-num ${rankClass}" style="margin-left:-10px">#${i+1}</span>
                    <div class="player-info">
                        <span class="player-name" style="color:${ds.hidden ? '#aaa' : ds.borderColor}">${ds.label}</span>
                        <span class="player-avg">Moy: ${player.avg} ${trendHTML}</span>
                    </div>
                    <div class="player-badges">${badgeHTML}</div>
                `;

                li.onclick = () => {
                    // L'index dans chart.datasets est i + 1 (Ã  cause de la moyenne du clan Ã  l'index 0)
                    const dsIndex = i + 1;
                    ds.hidden = !ds.hidden;
                    chart.update();
                    renderList();
                    checkVersusMode();
                };
                listContainer.appendChild(li);
            });
        }

        function toggleAll(show) {
            // Boucle Ã  partir de 1 pour ne pas masquer la Moyenne du Clan
            chart.data.datasets.slice(1).forEach(ds => ds.hidden = !show);
            chart.update();
            renderList();
            checkVersusMode();
        }

        // Expose toggleAll to global scope so inline `onclick` attributes work (module scope is not global)
        window.toggleAll = toggleAll;

        // --- LOGIQUE MVP & VERSUS ---
        
        function findMVP() {
            // Use the last week from the imported `weeks` array instead of a fixed index
            const lastWeekIndex = (Array.isArray(weeks) && weeks.length) ? (weeks.length - 1) : 11;
            
            // CrÃ©er un array des joueurs avec leurs scores
            const playersWithScores = brData
                .map(p => ({
                    name: p.name,
                    score: (p.scores && p.scores.length > lastWeekIndex) ? p.scores[lastWeekIndex] : null
                }))
                .filter(p => p.score !== null) // Garder seulement ceux qui ont un score
                .sort((a, b) => b.score - a.score) // Trier du meilleur au pire
                .slice(0, 2); // Prendre les 2 meilleurs

            if(playersWithScores.length > 0) {
                const mvpText = playersWithScores
                    .map(p => `${p.name.toUpperCase()} (${p.score})`)
                    .join(" & ");
                document.getElementById('mvpName').innerText = mvpText;
            }
        }

        function checkVersusMode() {
            // Filtre seulement les datasets des joueurs (index >= 1)
            const visibleDS = chart.data.datasets.slice(1).filter(d => !d.hidden);
            
            if (visibleDS.length === 2) {
                versusPanel.style.display = 'flex';
                
                const p1 = visibleDS[0];
                const p1Data = brData.find(r => r.name === p1.label);
                
                document.getElementById('br-p1-name').innerText = p1.label;
                document.getElementById('br-p1-name').style.color = p1.borderColor;
                document.getElementById('br-p1-avg').innerText = p1Data.avg;

                const p2 = visibleDS[1];
                const p2Data = brData.find(r => r.name === p2.label);
                
                document.getElementById('br-p2-name').innerText = p2.label;
                document.getElementById('br-p2-name').style.color = p2.borderColor;
                document.getElementById('br-p2-avg').innerText = p2Data.avg;
                
            } else {
                versusPanel.style.display = 'none';
            }
        }

        // --- ðŸ“¸ EXPORT FUNCTION CORRIGÃ‰E (avec LÃ©gende) ---
        function exportChart() {
            const originalCanvas = document.getElementById('brClanChart');
            
            // 1. CrÃ©er un conteneur et un canvas temporaires (cachÃ©s)
            const tempContainer = document.createElement('div');
            tempContainer.style.width = originalCanvas.width + 'px'; // Garde la taille originale
            tempContainer.style.height = originalCanvas.height + 'px';
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px'; // On le met hors Ã©cran
            document.body.appendChild(tempContainer);

            const tempCanvas = document.createElement('canvas');
            tempContainer.appendChild(tempCanvas);
            // Match the temporary canvas size to the original canvas so exported image keeps correct dimensions
            if (originalCanvas && originalCanvas.width) {
                tempCanvas.width = originalCanvas.width;
                tempCanvas.height = originalCanvas.height;
            } else {
                // Fallback sizes if original not available
                tempCanvas.width = 1200;
                tempCanvas.height = 600;
            }

            // 2. CrÃ©er une instance temporaire du Chart, mais AVEC la lÃ©gende
            const tempChart = new Chart(tempCanvas.getContext('2d'), {
                type: 'line',
                data: chart.data, // Utilise les donnÃ©es actuelles (avec les joueurs cachÃ©s/visibles)
                options: {
                    ...chart.options, // Garde toutes les options (Ã©chelles, couleurs, zones, etc.)
                    plugins: {
                        ...chart.options.plugins,
                        legend: { 
                            display: true, // <--- C'EST Ã‡A QUI AJOUTE LA LÃ‰GENDE !
                            labels: { 
                                color: 'white',
                                font: { size: 14 }
                            }
                        }
                    }
                },
                // RÃ©appliquer les plugins nÃ©cessaires, comme les zones de rangs
                plugins: [rankZonesPlugin] 
            });

            // On attend un micro-moment pour que Chart.js rende le graphique avec la lÃ©gende
            setTimeout(() => {
                // CrÃ©er un canvas final avec un fond noir (car le plugin ne dessine que la zone du graph)
                const finalCanvas = document.createElement('canvas');
                finalCanvas.width = tempCanvas.width;
                finalCanvas.height = tempCanvas.height;
                const finalCtx = finalCanvas.getContext('2d');
                
                // Dessiner le fond noir
                finalCtx.fillStyle = '#1e1e1e';
                finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                
                // Dessiner le graphique temporaire (avec lÃ©gende) sur le fond noir
                finalCtx.drawImage(tempCanvas, 0, 0);

                // Exportation
                const image = finalCanvas.toDataURL('image/png');
                const link = document.createElement('a');
                link.href = image;
                link.download = 'CircledFight_Graph_avec_Legende.png';
                document.body.appendChild(link);
                link.click();
                
                // Nettoyage
                tempChart.destroy(); // DÃ©truire l'instance
                link.remove();
                tempContainer.remove();
                finalCanvas.remove();
            }, 100);
        }

        // Expose export function to global scope for header button onclick
        window.exportChart = exportChart;


        // Lancement
        findMVP();
        renderList();
        checkVersusMode(); 

    </script>
</body>
</html>